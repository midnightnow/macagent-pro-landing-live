/**
 * MacAgent Pro - Web-to-Native Conversion Analytics Tracker
 * Tracks user journey from web preview to native app download
 * Privacy-first: No personal data collection, anonymous usage patterns only
 */

class ConversionAnalytics {
    constructor() {
        this.sessionId = this.generateSessionId();
        this.startTime = Date.now();
        this.events = [];
        this.conversationCount = 0;
        this.upgradePromptsShown = 0;
        this.featuresExplored = new Set();
        
        this.initializeTracking();
    }
    
    generateSessionId() {
        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    initializeTracking() {
        // Track page load and initial engagement
        this.trackEvent('page_loaded', {
            timestamp: Date.now(),
            userAgent: navigator.userAgent,
            screenResolution: `${screen.width}x${screen.height}`,
            viewport: `${window.innerWidth}x${window.innerHeight}`
        });
        
        // Track scroll depth for engagement measurement
        this.setupScrollTracking();
        
        // Track interaction with web app
        this.setupWebAppTracking();
        
        // Track upgrade prompts and responses
        this.setupUpgradeTracking();
        
        // Track exit intent
        this.setupExitTracking();
        
        // Send analytics periodically
        this.startAnalyticsHeartbeat();
    }
    
    trackEvent(eventName, data = {}) {
        const event = {\n            id: this.generateEventId(),\n            sessionId: this.sessionId,\n            event: eventName,\n            timestamp: Date.now(),\n            timeFromStart: Date.now() - this.startTime,\n            ...data\n        };\n        \n        this.events.push(event);\n        \n        // Send critical events immediately\n        if (this.isCriticalEvent(eventName)) {\n            this.sendAnalytics([event]);\n        }\n        \n        console.log('ðŸ“Š Analytics Event:', eventName, data);\n    }\n    \n    generateEventId() {\n        return 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);\n    }\n    \n    isCriticalEvent(eventName) {\n        return [\n            'download_clicked',\n            'trial_started', \n            'upgrade_selected',\n            'conversion_completed',\n            'session_abandoned'\n        ].includes(eventName);\n    }\n    \n    setupScrollTracking() {\n        let maxScroll = 0;\n        let scrollMilestones = [25, 50, 75, 90, 100];\n        let trackedMilestones = new Set();\n        \n        window.addEventListener('scroll', () => {\n            const scrollPercent = Math.round(\n                (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100\n            );\n            \n            maxScroll = Math.max(maxScroll, scrollPercent);\n            \n            // Track scroll milestones\n            scrollMilestones.forEach(milestone => {\n                if (scrollPercent >= milestone && !trackedMilestones.has(milestone)) {\n                    trackedMilestones.add(milestone);\n                    this.trackEvent('scroll_milestone', {\n                        percentage: milestone,\n                        timeToReach: Date.now() - this.startTime\n                    });\n                }\n            });\n        });\n        \n        // Track final scroll depth on page unload\n        window.addEventListener('beforeunload', () => {\n            this.trackEvent('page_exit', {\n                maxScrollPercent: maxScroll,\n                sessionDuration: Date.now() - this.startTime\n            });\n        });\n    }\n    \n    setupWebAppTracking() {\n        // Track chat interactions\n        const originalSendMessage = window.sendMessage;\n        if (originalSendMessage) {\n            window.sendMessage = () => {\n                this.conversationCount++;\n                this.trackEvent('chat_message_sent', {\n                    messageNumber: this.conversationCount,\n                    timeFromStart: Date.now() - this.startTime\n                });\n                \n                return originalSendMessage.apply(this, arguments);\n            };\n        }\n        \n        // Track suggestion chip clicks\n        document.querySelectorAll('.suggestion-chip').forEach((chip, index) => {\n            chip.addEventListener('click', () => {\n                this.trackEvent('suggestion_clicked', {\n                    suggestion: chip.textContent.trim(),\n                    position: index,\n                    timeFromStart: Date.now() - this.startTime\n                });\n            });\n        });\n        \n        // Track feature card exploration\n        document.querySelectorAll('.tier-card').forEach((card, index) => {\n            const observer = new IntersectionObserver((entries) => {\n                entries.forEach(entry => {\n                    if (entry.isIntersecting) {\n                        const tierName = card.querySelector('.tier-title')?.textContent || `tier_${index}`;\n                        if (!this.featuresExplored.has(tierName)) {\n                            this.featuresExplored.add(tierName);\n                            this.trackEvent('feature_tier_viewed', {\n                                tierName: tierName,\n                                timeFromStart: Date.now() - this.startTime\n                            });\n                        }\n                    }\n                });\n            }, { threshold: 0.5 });\n            \n            observer.observe(card);\n        });\n    }\n    \n    setupUpgradeTracking() {\n        // Track upgrade prompt displays\n        const originalAddMessage = window.addMessage;\n        if (originalAddMessage) {\n            window.addMessage = (content, isUser) => {\n                if (!isUser && content.includes('Download MacAgent Pro')) {\n                    this.upgradePromptsShown++;\n                    this.trackEvent('upgrade_prompt_shown', {\n                        promptNumber: this.upgradePromptsShown,\n                        conversationCount: this.conversationCount,\n                        timeFromStart: Date.now() - this.startTime\n                    });\n                }\n                \n                return originalAddMessage.apply(this, arguments);\n            };\n        }\n        \n        // Track download button clicks\n        document.querySelectorAll('.btn-primary, .btn-secondary').forEach(button => {\n            button.addEventListener('click', () => {\n                const buttonText = button.textContent.trim();\n                \n                if (buttonText.includes('Download') || buttonText.includes('Trial')) {\n                    this.trackEvent('download_clicked', {\n                        buttonText: buttonText,\n                        buttonLocation: this.getButtonLocation(button),\n                        conversationsHad: this.conversationCount,\n                        upgradePromptsShown: this.upgradePromptsShown,\n                        featuresExplored: Array.from(this.featuresExplored),\n                        timeFromStart: Date.now() - this.startTime\n                    });\n                }\n            });\n        });\n        \n        // Track daily limit reached (strong conversion signal)\n        const originalGetResponse = window.getResponse;\n        if (originalGetResponse) {\n            window.getResponse = (message) => {\n                const response = originalGetResponse.apply(this, arguments);\n                \n                if (response.includes('daily limit')) {\n                    this.trackEvent('daily_limit_reached', {\n                        conversationCount: this.conversationCount,\n                        timeFromStart: Date.now() - this.startTime,\n                        lastMessage: message\n                    });\n                }\n                \n                return response;\n            };\n        }\n    }\n    \n    getButtonLocation(button) {\n        const rect = button.getBoundingClientRect();\n        return {\n            section: this.getClosestSection(button),\n            position: `${Math.round(rect.left)},${Math.round(rect.top)}`,\n            visible: rect.top >= 0 && rect.top <= window.innerHeight\n        };\n    }\n    \n    getClosestSection(element) {\n        const sections = ['hero', 'feature-comparison', 'web-app'];\n        let closestSection = 'unknown';\n        let closestDistance = Infinity;\n        \n        sections.forEach(sectionClass => {\n            const section = document.querySelector(`.${sectionClass}`);\n            if (section) {\n                const distance = Math.abs(\n                    element.getBoundingClientRect().top - section.getBoundingClientRect().top\n                );\n                if (distance < closestDistance) {\n                    closestDistance = distance;\n                    closestSection = sectionClass;\n                }\n            }\n        });\n        \n        return closestSection;\n    }\n    \n    setupExitTracking() {\n        // Track exit intent (mouse leaving viewport)\n        document.addEventListener('mouseleave', (e) => {\n            if (e.clientY <= 0) {\n                this.trackEvent('exit_intent', {\n                    conversationsHad: this.conversationCount,\n                    upgradePromptsShown: this.upgradePromptsShown,\n                    timeFromStart: Date.now() - this.startTime,\n                    featuresExplored: Array.from(this.featuresExplored)\n                });\n            }\n        });\n        \n        // Track tab visibility changes\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                this.trackEvent('tab_hidden', {\n                    timeFromStart: Date.now() - this.startTime\n                });\n            } else {\n                this.trackEvent('tab_visible', {\n                    timeFromStart: Date.now() - this.startTime\n                });\n            }\n        });\n    }\n    \n    startAnalyticsHeartbeat() {\n        // Send analytics batch every 30 seconds\n        setInterval(() => {\n            this.sendAnalyticsBatch();\n        }, 30000);\n        \n        // Send final batch on page unload\n        window.addEventListener('beforeunload', () => {\n            this.sendAnalyticsBatch();\n        });\n    }\n    \n    sendAnalyticsBatch() {\n        if (this.events.length === 0) return;\n        \n        const batch = {\n            sessionId: this.sessionId,\n            events: this.events.slice(), // Copy events array\n            sessionSummary: {\n                duration: Date.now() - this.startTime,\n                conversationCount: this.conversationCount,\n                upgradePromptsShown: this.upgradePromptsShown,\n                featuresExplored: Array.from(this.featuresExplored),\n                deviceType: this.getDeviceType(),\n                browserType: this.getBrowserType()\n            }\n        };\n        \n        this.sendAnalytics(batch.events);\n        this.events = []; // Clear sent events\n    }\n    \n    sendAnalytics(events) {\n        // Privacy-first: Only send anonymous usage patterns\n        const analyticsData = {\n            events: events,\n            timestamp: Date.now(),\n            version: '1.0.0'\n        };\n        \n        // In production, send to analytics endpoint\n        if (window.location.hostname !== 'localhost') {\n            fetch('/api/analytics', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(analyticsData)\n            }).catch(err => {\n                console.warn('Analytics send failed:', err);\n            });\n        } else {\n            console.log('ðŸ“Š Analytics Data (Dev Mode):', analyticsData);\n        }\n    }\n    \n    getDeviceType() {\n        const userAgent = navigator.userAgent.toLowerCase();\n        if (/ipad|tablet/.test(userAgent)) return 'tablet';\n        if (/mobile|phone/.test(userAgent)) return 'mobile';\n        return 'desktop';\n    }\n    \n    getBrowserType() {\n        const userAgent = navigator.userAgent.toLowerCase();\n        if (userAgent.includes('chrome')) return 'chrome';\n        if (userAgent.includes('firefox')) return 'firefox';\n        if (userAgent.includes('safari')) return 'safari';\n        if (userAgent.includes('edge')) return 'edge';\n        return 'other';\n    }\n    \n    // Public API for manual event tracking\n    trackConversion(type, data = {}) {\n        this.trackEvent('conversion', {\n            conversionType: type,\n            ...data\n        });\n    }\n    \n    trackFeatureInterest(feature, data = {}) {\n        this.trackEvent('feature_interest', {\n            feature: feature,\n            ...data\n        });\n    }\n    \n    trackUpgradeBarrier(barrier, data = {}) {\n        this.trackEvent('upgrade_barrier', {\n            barrier: barrier,\n            ...data\n        });\n    }\n    \n    // Get conversion insights\n    getConversionInsights() {\n        return {\n            sessionDuration: Date.now() - this.startTime,\n            engagement: {\n                conversationCount: this.conversationCount,\n                featuresExplored: this.featuresExplored.size,\n                upgradePromptsShown: this.upgradePromptsShown\n            },\n            conversionSignals: {\n                dailyLimitReached: this.events.some(e => e.event === 'daily_limit_reached'),\n                downloadClicked: this.events.some(e => e.event === 'download_clicked'),\n                deepEngagement: this.conversationCount >= 5,\n                featureExploration: this.featuresExplored.size >= 2\n            }\n        };\n    }\n}\n\n// Initialize analytics when DOM is ready\nlet conversionAnalytics;\n\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n        conversionAnalytics = new ConversionAnalytics();\n        window.conversionAnalytics = conversionAnalytics; // Make available globally\n    });\n} else {\n    conversionAnalytics = new ConversionAnalytics();\n    window.conversionAnalytics = conversionAnalytics;\n}\n\n// Export for module usage\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = ConversionAnalytics;\n}